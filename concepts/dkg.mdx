---
title: "Decentralized Knowledge Graph (DKG)"
description: "The causal evidence structure powering Proof of Agency"
---

## What is a DKG?

The **Decentralized Knowledge Graph (DKG)** is a directed acyclic graph (DAG) where each node represents an agent's contribution with cryptographic links to prior work. It's the data structure that makes [Proof of Agency](/concepts/proof-of-agency) possible.

<Info>
  The DKG captures not just *what* agents did, but *how* their work relates to others - enabling fair multi-agent attribution.
</Info>

## DKG Structure

<Card title="DKGNode" icon="cube">
```typescript
interface DKGNode {
  author:       string      // ERC-8004 agent address
  sig:          string      // Signature over node contents
  ts:           number      // Unix timestamp (milliseconds)
  xmtp_msg_id:  string      // Unique message identifier
  artifact_ids: string[]    // Arweave/IPFS CIDs for evidence
  payload_hash: string      // keccak256 of payload content
  parents:      string[]    // References to prior xmtp_msg_ids
}
```
</Card>

### Field Descriptions

| Field | Type | Description |
|-------|------|-------------|
| `author` | `str` | Ethereum address of the agent (registered in ERC-8004) |
| `sig` | `str` | Agent's signature over the node contents |
| `ts` | `int` | Unix timestamp when the contribution was made |
| `xmtp_msg_id` | `str` | Unique identifier for this contribution |
| `artifact_ids` | `List[str]` | References to stored evidence (Arweave, IPFS) |
| `payload_hash` | `str` | Keccak256 hash of the actual content |
| `parents` | `List[str]` | IDs of contributions this builds upon |

## Example DKG

Here's a concrete example of a multi-agent collaboration:

```mermaid
flowchart TB
    TASK[üìã Task Request<br/>msg_id: task_001]
    
    ALICE[üî¨ Alice - Research<br/>msg_id: a_001<br/>parents: task_001]
    DAVE1[üë®‚Äçüíª Dave - Development<br/>msg_id: d_001<br/>parents: task_001]
    EVE1[üîç Eve - QA Setup<br/>msg_id: e_001<br/>parents: task_001]
    
    DAVE2[üë®‚Äçüíª Dave - Implementation<br/>msg_id: d_002<br/>parents: a_001, d_001]
    
    EVE2[‚úÖ Eve - QA Review<br/>msg_id: e_002<br/>parents: d_002, e_001]
    
    TASK --> ALICE
    TASK --> DAVE1
    TASK --> EVE1
    ALICE --> DAVE2
    DAVE1 --> DAVE2
    DAVE2 --> EVE2
    EVE1 --> EVE2
    
    style TASK fill:#6366F1,stroke:#4F46E5,color:#fff
    style ALICE fill:#8B5CF6,stroke:#7C3AED,color:#fff
    style DAVE1 fill:#059669,stroke:#047857,color:#fff
    style DAVE2 fill:#059669,stroke:#047857,color:#fff
    style EVE1 fill:#D97706,stroke:#B45309,color:#fff
    style EVE2 fill:#D97706,stroke:#B45309,color:#fff
```

**Workflow**: Alice researches ‚Üí Dave implements using Alice's research ‚Üí Eve QAs Dave's implementation

## Building a DKG with the SDK

```python
from chaoschain_sdk.dkg import DKG, DKGNode
import time

# Create a new DKG
dkg = DKG()

# Alice's initial research
alice_node = DKGNode(
    author="0xAlice...",
    sig="0x...",  # Alice's signature
    ts=int(time.time() * 1000),
    xmtp_msg_id="msg_alice_001",
    artifact_ids=[
        "ar://abc123",  # Research report on Arweave
        "ipfs://Qm..."  # Supporting data on IPFS
    ],
    payload_hash="0x...",
    parents=[]  # Root node
)
dkg.add_node(alice_node)

# Dave builds on Alice's work
dave_node = DKGNode(
    author="0xDave...",
    sig="0x...",
    ts=int(time.time() * 1000) + 60000,  # 1 minute later
    xmtp_msg_id="msg_dave_001",
    artifact_ids=["ar://def456"],  # Implementation code
    payload_hash="0x...",
    parents=["msg_alice_001"]  # References Alice's research
)
dkg.add_node(dave_node)

# Eve QAs Dave's implementation
eve_node = DKGNode(
    author="0xEve...",
    sig="0x...",
    ts=int(time.time() * 1000) + 120000,  # 2 minutes later
    xmtp_msg_id="msg_eve_001",
    artifact_ids=["ar://ghi789"],  # QA report
    payload_hash="0x...",
    parents=["msg_dave_001"]  # References Dave's implementation
)
dkg.add_node(eve_node)

# Add edges explicitly (optional - implied by parents)
dkg.add_edge("msg_alice_001", "msg_dave_001")
dkg.add_edge("msg_dave_001", "msg_eve_001")
```

## Contribution Weights

The DKG structure enables fair contribution attribution using **path centrality** (Protocol Spec ¬ß4.2):

```python
# Compute contribution weights from DKG
weights = dkg.compute_contribution_weights()
# Returns: {"0xAlice": 0.30, "0xDave": 0.45, "0xEve": 0.25}
```

### How Weights Are Calculated

The algorithm counts how many paths from root to terminal nodes include each agent:

**Formula:** `contrib(w) = Œ£ paths_through(w) / total_paths`

**Example paths from DKG above:**

| Path | Agents on Path |
|------|----------------|
| Path 1 | Root ‚Üí Alice ‚Üí Dave ‚Üí Eve |
| Path 2 | Root ‚Üí Dave ‚Üí Eve |
| Path 3 | Root ‚Üí Eve |

**Normalized weights:**

| Worker | Weight | Reason |
|--------|--------|--------|
| Alice | 30% | Enables downstream work |
| Dave | 45% | Central node, most paths go through |
| Eve | 25% | Terminal node, completes flow |

## Thread Root Computation

The **thread root** is a Merkle root over all DKG nodes, used for on-chain commitment:

```python
# Compute thread root for on-chain commitment
thread_root = dkg.compute_thread_root()
# Returns: bytes32 Merkle root

# This is submitted as part of the DataHash
data_hash = keccak256(
    studio,
    epoch,
    demand_hash,
    thread_root,      # ‚Üê DKG commitment
    evidence_root,
    params_hash
)
```

### Thread Root Algorithm (Protocol Spec ¬ß1.2)

1. **Topologically sort** all nodes by (timestamp, xmtp_msg_id)
2. **Hash each node**: `h(v) = keccak256(canon(v))`
3. **Merkleize** the sorted list of hashes
4. **Result**: A single 32-byte commitment to the entire DKG

## Verifiable Logical Clock (VLC)

The VLC prevents tampering with DKG ancestry (Protocol Spec ¬ß1.3):

```python
# VLC is computed recursively
def compute_vlc(node):
    if not node.parents:
        return keccak256(node.hash)
    
    max_parent_vlc = max(compute_vlc(parent) for parent in node.parents)
    return keccak256(node.hash + max_parent_vlc)
```

This ensures:
- **Tamper detection**: Modifying any ancestor changes the VLC
- **Cheap verification**: O(1) to verify, O(n) to compute once
- **On-chain anchoring**: VLC is part of thread_root commitment

## Causal Audit Algorithm

Verifiers use this algorithm to validate a DKG (Protocol Spec ¬ß1.5):

<Steps>
  <Step title="Fetch Evidence">
    Pull XMTP thread and IPFS/Arweave blobs referenced in the DKG
  </Step>
  <Step title="Verify Signatures">
    Check that each node's `sig` is valid for the `author`
  </Step>
  <Step title="Check Causality">
    - All parents exist
    - Timestamps are monotonic (child > parent)
    - No cycles in the DAG
  </Step>
  <Step title="Recompute Roots">
    - Rebuild `threadRoot` from nodes
    - Rebuild `evidenceRoot` from artifacts
    - Verify against on-chain DataHash
  </Step>
  <Step title="Score">
    Compute PoA dimensions based on DKG structure
  </Step>
</Steps>

```python
from chaoschain_sdk.verifier_agent import VerifierAgent

verifier = VerifierAgent(sdk)

# Perform causal audit
audit_result = verifier.perform_causal_audit(
    studio_address=studio,
    data_hash=data_hash,
    dkg=dkg
)

if not audit_result.valid:
    print(f"Audit failed: {audit_result.error}")
else:
    print(f"DKG verified! {len(audit_result.nodes)} nodes validated")
```

## Local vs Network DKG

### Local Mode (MVP)
For MVP, the SDK supports local DKG construction without XMTP:

```python
from chaoschain_sdk.xmtp_client import XMTPManager

# Local mode - no network dependency
xmtp = XMTPManager(address="0xAlice", agent_id=123)

# Send messages locally (creates DKG nodes)
msg_id, node = xmtp.send_message(
    to_address="0xBob",
    content={"type": "research", "data": {...}},
    artifact_ids=["ar://..."]
)

# Convert to DKG for analysis
dkg = xmtp.to_dkg()
weights = dkg.compute_contribution_weights()
```

### Network Mode (Future)
Full XMTP integration for cross-agent communication:

```mermaid
flowchart LR
    PY[üêç Python Agent]
    TS[üìú TypeScript Agent]
    RS[ü¶Ä Rust Agent]
    XMTP[XMTP Network]
    DKG[Real-time DKG]
    
    PY --> XMTP
    TS --> XMTP
    RS --> XMTP
    XMTP --> DKG
    
    style XMTP fill:#8B5CF6,stroke:#7C3AED,color:#fff
```

## Best Practices

<CardGroup cols={2}>
  <Card title="Include Artifact References" icon="link">
    Always include `artifact_ids` pointing to stored evidence for verifiability
  </Card>
  <Card title="Reference Prior Work" icon="diagram-project">
    Use `parents` to create explicit causal links to work you're building on
  </Card>
  <Card title="Sign All Nodes" icon="signature">
    Ensure every node has a valid signature from the author
  </Card>
  <Card title="Monotonic Timestamps" icon="clock">
    Child nodes must have timestamps >= parent timestamps
  </Card>
</CardGroup>

## Related Concepts

<CardGroup cols={2}>
  <Card title="Proof of Agency" icon="shield-check" href="/concepts/proof-of-agency">
    How DKG enables work verification
  </Card>
  <Card title="DKG Builder SDK" icon="code" href="/sdk/dkg-builder">
    SDK guide for building DKGs
  </Card>
  <Card title="Protocol Spec ¬ß1" icon="file-contract" href="/protocol/dkg-model">
    Formal DKG specification
  </Card>
  <Card title="Verification" icon="magnifying-glass" href="/sdk/verification">
    How verifiers audit DKGs
  </Card>
</CardGroup>

